package as3_foundation.utils{	import flash.display.BitmapData;	/**	 * @private	 * 不使用？ 	 * @author tkn	 * 	 */		public class Color	{		public function Color()		{		}		public static function hsbToRgb(h:Number, s:Number, b:Number):uint		{			while (h < 0)			{				h += 360;			}			while (h >= 360)			{				h -= 360;			}			var h2:Number = Math.floor(h / 60);			var f:Number = h / 60 - h2;			var full:Number = 255;			var empty:Number = 0;			var valueUp:Number = 255 * f;			var valueDown:Number = 255 * (1 - f);			var red:Number = 0;			var green:Number = 0;			var blue:Number = 0;			switch (h2)			{				case 0:					red = full;					green = valueUp;					blue = empty;					break;				case 1:					red = valueDown;					green = full;					blue = empty;					break;				case 2:					red = empty;					green = full;					blue = valueUp;					break;				case 3:					red = empty;					green = valueDown;					blue = full;					break;				case 4:					red = valueUp;					green = empty;					blue = full;					break;				case 5:					red = full;					green = empty;					blue = valueDown;			}			var max:Number = Math.max(Math.max(red, green), blue);			red = max - (max - red) * s;			green = max - (max - green) * s;			blue = max - (max - blue) * s;			red *= b;			green *= b;			blue *= b;			var ret:uint = int(red) << 16 | int(green) << 8 | int(blue);			return ret;		}		public static function rgbToHsb(rgb):Array		{			var ret:Array = [];			var _r:Number = rgb >> 16 & 0xff;			var _g:Number = rgb >> 8 & 0xff;			var _b:Number = rgb >> 0 & 0xff;			var _s:Number;			var _v:Number;			var _h:Number;			if (_r != _g || _r != _b)			{				if (_g > _b)				{					if (_r > _g)					{ //r>g>b						_v = _r / 255;						_s = (_r - _b) / _r;						_h = 60 * (_g - _b) / (_r - _b);					}					else if (_r < _b)					{ //g>b>r						_v = _g / 255;						_s = (_g - _r) / _g;						_h = 60 * (_b - _r) / (_g - _r) + 120;					}					else					{ //g=>r=>b						_v = _g / 255;						_s = (_g - _b) / _g;						_h = 60 * (_b - _r) / (_g - _b) + 120;					}				}				else				{					if (_r > _b)					{ // r>b=>g						_v = _r / 255;						_s = (_r - _g) / _r;						_h = 60 * (_g - _b) / (_r - _g);						if (_h < 0)							_h += 360;					}					else if (_r < _g)					{ //b=>g>r						_v = _b / 255;						_s = (_b - _r) / _b;						_h = 60 * (_r - _g) / (_b - _r) + 240;					}					else					{ //b=>r=>g						_v = _b / 255;						_s = (_b - _g) / _b;						_h = 60 * (_r - _g) / (_b - _g) + 240;					}				}			}			else			{				_h = _s = 0;				_v = _r / 255;			}			//check_rgb_flg = false;			return [_h, _s, _v];		}		/* public static function rgbToHsb( rgb:uint ):Array			 {			 var ret:Array = [];			 var red:Number = rgb >> 16 & 0xff;			 var green:Number = rgb >> 8 & 0xff;			 var blue:Number = rgb >> 0 & 0xff;			 var max:Number = Math.max( Math.max( red, green ), blue );			 var min:Number = Math.min( Math.min( red, green ), blue );			 if( red == green && green == blue )			 {			 ret[ 0 ] = ret[ 1 ] = ret[ 2 ] = 0;			 return ret;			 }			 else			 {			 if( max == red && min == blue )			 {			 ret[ 0 ] = 0 + ( green - min ) / ( max - min ) * 60;			 }			 else if( max == green && min == blue )			 {			 ret[ 0 ] = 60 + ( red - min ) / ( max - min ) * 60; //			 }			 else if( max == green && min == red )			 {			 ret[ 0 ] = 120 + ( blue - min ) / ( max - min ) * 60;			 }			 else if( max == blue && min == red )			 {			 ret[ 0 ] = 180 + ( green - min ) / ( max - min ) * 60;			 }			 else if( max == blue && min == green )			 {			 ret[ 0 ] = 240 + ( red - min ) / ( max - min ) * 60;			 }			 else if( max == red && min == green )			 {			 ret[ 0 ] = 300 + ( blue - min ) / ( max - min ) * 60;			 }			 ret[ 1 ] = ( max - min ) / max;			 ret[ 2 ] = max / 255;			 }			 return ret;		 } */		public static function getAvarageColor(bmd:BitmapData, xx:Number, yy:Number, w:Number, h:Number):uint		{			var rrr:uint = 0;			var ggg:uint = 0;			var bbb:uint = 0;			for (var y:Number = yy; y < yy + h; ++y)			{				for (var x:Number = xx; x < xx + w; ++x)				{					var col:uint = bmd.getPixel(x, y);					rrr += 0xff & col >> 16;					ggg += 0xff & col >> 8;					bbb += 0xff & col >> 0;				}			}			rrr /= w * h;			ggg /= w * h;			bbb /= w * h;			return int(rrr) << 16 | int(ggg) << 8 | int(bbb);		}	}}